<h2>構文ツリー</h2>
既に説明済みですが復習がてらにもう一度説明します。<br />構文ツリーは「構文ノード」「構文トークン」「構文トリビア」から構成されるドキュメント要素を階層構造で表したものです。
<img src="/?S00/0251/syntaxTree_syntaxNode_syntaxToken_syntaxTrivia.png" alt="構文ツリー" />
構文ツリーの頂点に位置する構文ノードを取得したら、それ配下の構文ノード・構文トークン・構文トリビアを探索することをコードを解析します。<br />通常は構文トークン・構文トリビアを探索せずに、その親となる構文ノードを探索対象とします。
<h2>構文ノード</h2>
こちらも既に説明済みですね♪<br />構文ノードは構文ツリーの主要な構成要素で、構文ノードを再帰的に保持します。<br /><br />構文解析では、構文ノードの探索がメインになりますので、しっかりと理解して下さい。<br />構文ノードは「SyntaxNode」クラスで表されます。<br />「SyntaxNode」クラスは以下のプロパティ・メソッドを保持します。
<div class="scroll-600w">
	<table>
		<caption>プロパティ</caption>
		<tbody>
			<tr>
				<th>ContainsAnnotations</th>
				<td>Determines whether this node or any sub node, token or trivia has annotations.</td>
			</tr>
			<tr>
				<th>ContainsDiagnostics</th>
				<td>Determines whether this node or any of its descendant nodes, tokens or trivia have any diagnostics on them.</td>
			</tr>
			<tr>
				<th>ContainsDirectives</th>
				<td>Determines whether this node has any descendant preprocessor directives.</td>
			</tr>
			<tr>
				<th>ContainsSkippedText</th>
				<td>Determines whether this node has any descendant skipped text.</td>
			</tr>
			<tr>
				<th>FullSpan</th>
				<td>The absolute span of this node in characters, including its leading and trailing trivia.</td>
			</tr>
			<tr>
				<th>HasLeadingTrivia</th>
				<td>Determines whether this node has any leading trivia.</td>
			</tr>
			<tr>
				<th>HasStructuredTrivia</th>
				<td>Determines whether a descendant trivia of this node is structured.</td>
			</tr>
			<tr>
				<th>HasTrailingTrivia</th>
				<td>Determines whether this node has any trailing trivia.</td>
			</tr>
			<tr>
				<th>IsMissing</th>
				<td>Determines whether the node represents a language construct that was actually parsed from the source code. Missing nodes are generated by the parser in error scenarios to represent constructs that should have been present in the source code in order to compile successfully but were actually missing.</td>
			</tr>
			<tr>
				<th>IsStructuredTrivia</th>
				<td>Determines whether this node represents a structured trivia.</td>
			</tr>
			<tr>
				<th>KindText</th>
				<td></td>
			</tr>
			<tr>
				<th>Language</th>
				<td>The language name that this node is syntax of.</td>
			</tr>
			<tr>
				<th>Parent</th>
				<td>The node that contains this node in its ChildNodes() collection.</td>
			</tr>
			<tr>
				<th>ParentTrivia</th>
				<td></td>
			</tr>
			<tr>
				<th>RawKind</th>
				<td>An integer representing the language specific kind of this node.</td>
			</tr>
			<tr>
				<th>Span</th>
				<td>The absolute span of this node in characters, not including its leading and trailing trivia.</td>
			</tr>
			<tr>
				<th>SpanStart</th>
				<td>Same as accessing Start on Span.</td>
			</tr>
			<tr>
				<th>SyntaxTree</th>
				<td>Returns SyntaxTree that owns the node or null if node does not belong to a SyntaxTree</td>
			</tr>
			<tr>
				<th>SyntaxTreeCore</th>
				<td>Returns SyntaxTree that owns the node. If the node does not belong to a tree then one will be generated.</td>
			</tr>
		</tbody>
	</table>
</div>
<p><a href="https://docs.microsoft.com/ja-jp/dotnet/api/microsoft.codeanalysis.syntaxnode?view=roslyn-dotnet">MS公式ドキュメント</a>より。</p>
<div class="scroll-600w">
	<table>
		<caption>メソッド</caption>
		<tbody>
			<tr>
				<th>Ancestors(Boolean)</th>
				<td>Gets a list of ancestor nodes</td>
			</tr>
			<tr>
				<th>AncestorsAndSelf(Boolean)</th>
				<td>Gets a list of ancestor nodes (including this node)</td>
			</tr>
			<tr>
				<th>ChildNodes()</th>
				<td>Gets a list of the child nodes in prefix document order.</td>
			</tr>
			<tr>
				<th>ChildNodesAndTokens()</th>
				<td>The list of child nodes and tokens of this node, where each element is a SyntaxNodeOrToken instance.</td>
			</tr>
			<tr>
				<th>ChildThatContainsPosition(Int32)</th>
				<td></td>
			</tr>
			<tr>
				<th>ChildTokens()</th>
				<td>Gets a list of the direct child tokens of this node.</td>
			</tr>
			<tr>
				<th>Contains(SyntaxNode)</th>
				<td>Determines if the specified node is a descendant of this node. Returns true for current node.</td>
			</tr>
			<tr>
				<th>CopyAnnotationsTo&lt;T&gt;(T)</th>
				<td>Copies all SyntaxAnnotations, if any, from this SyntaxNode instance and attaches them to a new instance based on node.</td>
			</tr>
			<tr>
				<th>DescendantNodes(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of descendant nodes in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodes(TextSpan, Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of descendant nodes in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodesAndSelf(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of descendant nodes (including this node) in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodesAndSelf(TextSpan, Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of descendant nodes (including this node) in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodesAndTokens(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of descendant nodes and tokens in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodesAndTokens(TextSpan, Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of the descendant nodes and tokens in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodesAndTokensAndSelf(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of descendant nodes and tokens (including this node) in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantNodesAndTokensAndSelf(TextSpan, Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of the descendant nodes and tokens (including this node) in prefix document order.</td>
			</tr>
			<tr>
				<th>DescendantTokens(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of all the tokens in the span of this node.</td>
			</tr>
			<tr>
				<th>DescendantTokens(TextSpan, Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Gets a list of all the tokens in the full span of this node.</td>
			</tr>
			<tr>
				<th>DescendantTrivia(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Get a list of all the trivia associated with the descendant nodes and tokens.</td>
			</tr>
			<tr>
				<th>DescendantTrivia(TextSpan, Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>Get a list of all the trivia associated with the descendant nodes and tokens.</td>
			</tr>
			<tr>
				<th>EquivalentToCore(SyntaxNode)</th>
				<td>Determine if this node is structurally equivalent to another.</td>
			</tr>
			<tr>
				<th>FindNode(TextSpan, Boolean, Boolean)</th>
				<td>Finds the node with the smallest FullSpan that contains span. getInnermostNodeForTie is used to determine the behavior in case of a tie (i.e. a node having the same span as its parent). If getInnermostNodeForTie is true, then it returns lowest descending node encompassing the given span. Otherwise, it returns the outermost node encompassing the given span.</td>
			</tr>
			<tr>
				<th>FindToken(Int32, Boolean)</th>
				<td>Finds a descendant token of this node whose span includes the supplied position.</td>
			</tr>
			<tr>
				<th>FindTokenCore(Int32, Boolean)</th>
				<td>Finds a descendant token of this node whose span includes the supplied position.</td>
			</tr>
			<tr>
				<th>FindTokenCore(Int32, Func&lt;SyntaxTrivia,Boolean&gt;)</th>
				<td>Finds a descendant token of this node whose span includes the supplied position.</td>
			</tr>
			<tr>
				<th>FindTrivia(Int32, Boolean)</th>
				<td>Finds a descendant trivia of this node whose span includes the supplied position.</td>
			</tr>
			<tr>
				<th>FindTrivia(Int32, Func&lt;SyntaxTrivia,Boolean&gt;)</th>
				<td>Finds a descendant trivia of this node at the specified position, where the position is within the span of the node.</td>
			</tr>
			<tr>
				<th>FindTriviaCore(Int32, Boolean)</th>
				<td>Finds a descendant trivia of this node whose span includes the supplied position.</td>
			</tr>
			<tr>
				<th>FirstAncestorOrSelf&lt;TNode,TArg&gt;(Func&lt;TNode,TArg,Boolean&gt;, TArg, Boolean)</th>
				<td>Gets the first node of type TNode that matches the predicate.</td>
			</tr>
			<tr>
				<th>FirstAncestorOrSelf&lt;TNode&gt;(Func&lt;TNode,Boolean&gt;, Boolean)</th>
				<td>Gets the first node of type TNode that matches the predicate.</td>
			</tr>
			<tr>
				<th>GetAnnotatedNodes(String)</th>
				<td>Gets all nodes with the specified annotation kind.</td>
			</tr>
			<tr>
				<th>GetAnnotatedNodes(SyntaxAnnotation)</th>
				<td>Gets all nodes with the specified annotation.</td>
			</tr>
			<tr>
				<th>GetAnnotatedNodesAndTokens(String)</th>
				<td>Gets all nodes and tokens with an annotation of the specified annotation kind.</td>
			</tr>
			<tr>
				<th>GetAnnotatedNodesAndTokens(String[])</th>
				<td>Gets all nodes and tokens with an annotation of the specified annotation kinds.</td>
			</tr>
			<tr>
				<th>GetAnnotatedNodesAndTokens(SyntaxAnnotation)</th>
				<td>Gets all nodes and tokens with the specified annotation.</td>
			</tr>
			<tr>
				<th>GetAnnotatedTokens(String)</th>
				<td>Gets all tokens with the specified annotation kind.</td>
			</tr>
			<tr>
				<th>GetAnnotatedTokens(SyntaxAnnotation)</th>
				<td>Gets all tokens with the specified annotation.</td>
			</tr>
			<tr>
				<th>GetAnnotatedTrivia(String)</th>
				<td>Gets all trivia with an annotation of the specified annotation kind.</td>
			</tr>
			<tr>
				<th>GetAnnotatedTrivia(String[])</th>
				<td>Gets all trivia with an annotation of the specified annotation kinds.</td>
			</tr>
			<tr>
				<th>GetAnnotatedTrivia(SyntaxAnnotation)</th>
				<td>Gets all trivia with the specified annotation.</td>
			</tr>
			<tr>
				<th>GetAnnotations(IEnumerable&lt;String&gt;)</th>
				<td>Gets all the annotations with the specified annotation kinds.</td>
			</tr>
			<tr>
				<th>GetAnnotations(String)</th>
				<td>Gets all the annotations with the specified annotation kind.</td>
			</tr>
			<tr>
				<th>GetDiagnostics()</th>
				<td>Gets a list of all the diagnostics in the sub tree that has this node as its root. This method does not filter diagnostics based on #pragmas and compiler options like nowarn, warnaserror etc.</td>
			</tr>
			<tr>
				<th>GetFirstToken(Boolean, Boolean, Boolean, Boolean)</th>
				<td>Gets the first token of the tree rooted by this node. Skips zero-width tokens.</td>
			</tr>
			<tr>
				<th>GetLastToken(Boolean, Boolean, Boolean, Boolean)</th>
				<td>Gets the last token of the tree rooted by this node. Skips zero-width tokens.</td>
			</tr>
			<tr>
				<th>GetLeadingTrivia()</th>
				<td>The list of trivia that appears before this node in the source code and are attached to a token that is a descendant of this node.</td>
			</tr>
			<tr>
				<th>GetLocation()</th>
				<td></td>
			</tr>
			<tr>
				<th>GetRed&lt;T&gt;(T, Int32)</th>
				<td></td>
			</tr>
			<tr>
				<th>GetRedAtZero&lt;T&gt;(T)</th>
				<td></td>
			</tr>
			<tr>
				<th>GetReference()</th>
				<td>Gets a SyntaxReference for this syntax node. CommonSyntaxReferences can be used to regain access to a syntax node without keeping the entire tree and source text in memory.</td>
			</tr>
			<tr>
				<th>GetText(Encoding, SourceHashAlgorithm)</th>
				<td>Gets the full text of this node as a new SourceText instance.</td>
			</tr>
			<tr>
				<th>GetTrailingTrivia()</th>
				<td>The list of trivia that appears after this node in the source code and are attached to a token that is a descendant of this node.</td>
			</tr>
			<tr>
				<th>HasAnnotation(SyntaxAnnotation)</th>
				<td>Determines whether this node has the specific annotation.</td>
			</tr>
			<tr>
				<th>HasAnnotations(IEnumerable&lt;String&gt;)</th>
				<td>Determines whether this node has any annotations with any of the specific annotation kinds.</td>
			</tr>
			<tr>
				<th>HasAnnotations(String)</th>
				<td>Determines whether this node has any annotations with the specific annotation kind.</td>
			</tr>
			<tr>
				<th>InsertNodesInListCore(SyntaxNode, IEnumerable&lt;SyntaxNode&gt;, Boolean)</th>
				<td></td>
			</tr>
			<tr>
				<th>InsertTokensInListCore(SyntaxToken, IEnumerable&lt;SyntaxToken&gt;, Boolean)</th>
				<td></td>
			</tr>
			<tr>
				<th>InsertTriviaInListCore(SyntaxTrivia, IEnumerable&lt;SyntaxTrivia&gt;, Boolean)</th>
				<td></td>
			</tr>
			<tr>
				<th>IsEquivalentTo(SyntaxNode)</th>
				<td>Determine whether this node is structurally equivalent to another.</td>
			</tr>
			<tr>
				<th>IsEquivalentTo(SyntaxNode, Boolean)</th>
				<td>Determines if two nodes are the same, disregarding trivia differences.</td>
			</tr>
			<tr>
				<th>IsEquivalentToCore(SyntaxNode, Boolean)</th>
				<td>Determines if two nodes are the same, disregarding trivia differences.</td>
			</tr>
			<tr>
				<th>IsIncrementallyIdenticalTo(SyntaxNode)</th>
				<td>Returns true if these two nodes are considered "incrementally identical". An incrementally identical node occurs when a SyntaxTree is incrementally parsed using WithChangedText(SourceText) and the incremental parser is able to take the node from the original tree and use it in its entirety in the new tree. In this case, the ToFullString() of each node will be the same, though they could have different parents, and may occur at different positions in their respective trees. If two nodes are incrementally identical, all children of each node will be incrementally identical as well.</td>
			</tr>
			<tr>
				<th>IsPartOfStructuredTrivia()</th>
				<td>Determines whether this node is a descendant of a structured trivia.</td>
			</tr>
			<tr>
				<th>NormalizeWhitespaceCore(String, String, Boolean)</th>
				<td></td>
			</tr>
			<tr>
				<th>RemoveNodesCore(IEnumerable&lt;SyntaxNode&gt;, SyntaxRemoveOptions)</th>
				<td>Creates a new tree of nodes with the specified node removed.</td>
			</tr>
			<tr>
				<th>ReplaceCore&lt;TNode&gt;(IEnumerable&lt;TNode&gt;, Func&lt;TNode,TNode,SyntaxNode&gt;, IEnumerable&lt;SyntaxToken&gt;, Func&lt;SyntaxToken,SyntaxToken,SyntaxToken&gt;, IEnumerable&lt;SyntaxTrivia&gt;, Func&lt;SyntaxTrivia,SyntaxTrivia,SyntaxTrivia&gt;)</th>
				<td>Creates a new tree of nodes with the specified nodes, tokens or trivia replaced.</td>
			</tr>
			<tr>
				<th>ReplaceNodeInListCore(SyntaxNode, IEnumerable&lt;SyntaxNode&gt;)</th>
				<td></td>
			</tr>
			<tr>
				<th>ReplaceTokenInListCore(SyntaxToken, IEnumerable&lt;SyntaxToken&gt;)</th>
				<td></td>
			</tr>
			<tr>
				<th>ReplaceTriviaInListCore(SyntaxTrivia, IEnumerable&lt;SyntaxTrivia&gt;)</th>
				<td></td>
			</tr>
			<tr>
				<th>SerializeTo(Stream, CancellationToken)</th>
				<td>Serializes the node to the given stream. Leaves the stream open for further writes.</td>
			</tr>
			<tr>
				<th>ToFullString()</th>
				<td>Returns full string representation of this node including its leading and trailing trivia.</td>
			</tr>
			<tr>
				<th>ToString()</th>
				<td>Returns the string representation of this node, not including its leading and trailing trivia.</td>
			</tr>
			<tr>
				<th>WriteTo(TextWriter)</th>
				<td>Writes the full text of this node to the specified TextWriter.</td>
			</tr>
			<tr>
				<th>***************</th>
				<td>***************</td>
			</tr>
			<tr>
				<th>GetFirstDirective(SyntaxNode, Func&lt;DirectiveTriviaSyntax,Boolean&gt;)</th>
				<td>Gets the first directive of the tree rooted by this node.</td>
			</tr>
			<tr>
				<th>GetLastDirective(SyntaxNode, Func&lt;DirectiveTriviaSyntax,Boolean&gt;)</th>
				<td>Gets the last directive of the tree rooted by this node.</td>
			</tr>
			<tr>
				<th>Kind(SyntaxNode)</th>
				<td>Returns SyntaxKind for SyntaxNode from RawKind property.</td>
			</tr>
			<tr>
				<th>TryGetInferredMemberName(SyntaxNode)</th>
				<td>Given an initializer expression infer the name of anonymous property or tuple element. Returns null if unsuccessful</td>
			</tr>
			<tr>
				<th>IsKind(SyntaxNode, SyntaxKind)</th>
				<td>Determines if SyntaxNode is of a specified kind.</td>
			</tr>
			<tr>
				<th>GetCurrentNode&lt;TNode&gt;(SyntaxNode, TNode)</th>
				<td>Gets the node within the subtree corresponding to the original tracked node. Use TrackNodes to start tracking nodes.</td>
			</tr>
			<tr>
				<th>GetCurrentNodes&lt;TNode&gt;(SyntaxNode, TNode)</th>
				<td>Gets the nodes within the subtree corresponding to the original tracked node. Use TrackNodes to start tracking nodes.</td>
			</tr>
			<tr>
				<th>GetCurrentNodes&lt;TNode&gt;(SyntaxNode, IEnumerable&lt;TNode&gt;)</th>
				<td>Gets the nodes within the subtree corresponding to the original tracked nodes. Use TrackNodes to start tracking nodes.</td>
			</tr>
			<tr>
				<th>TryGetInferredMemberName(SyntaxNode)</th>
				<td>Given an initializer expression infer the name of anonymous property or tuple element. Returns Nothing if unsuccessful</td>
			</tr>
			<tr>
				<th>GetDirectives(SyntaxNode, Func&lt;DirectiveTriviaSyntax,Boolean&gt;)</th>
				<td>Gets the DirectiveTriviaSyntax items for a specified SyntaxNode with optional filtering.</td>
			</tr>
			<tr>
				<th>GetFirstDirective(SyntaxNode, Func&lt;DirectiveTriviaSyntax,Boolean&gt;)</th>
				<td>Gets the first DirectiveTriviaSyntax item for a specified SyntaxNode.</td>
			</tr>
			<tr>
				<th>GetLastDirective(SyntaxNode, Func&lt;DirectiveTriviaSyntax,Boolean&gt;)</th>
				<td>Gets the last DirectiveTriviaSyntax item for a specified SyntaxNode.</td>
			</tr>
			<tr>
				<th>Kind(SyntaxNode)</th>
				<td>Returns SyntaxKind for SyntaxNode from RawKind property.</td>
			</tr>
			<tr>
				<th>IsKind(SyntaxNode, SyntaxKind)</th>
				<td>Determines if SyntaxNode is of a specified kind.</td>
			</tr>
		</tbody>
	</table>
</div>
<p><a href="https://docs.microsoft.com/ja-jp/dotnet/api/microsoft.codeanalysis.syntaxnode?view=roslyn-dotnet">MS公式ドキュメント</a>より。</p>
<div class="separator"></div>
構文ノードに関しては以下のプロパティ・メソッドをよく使用します。
<div class="scroll-600w">
	<table>
		<tbody>
			<tr>
				<th>Parent</th>
				<td>親ノードを表します。</td>
			</tr>
			<tr>
				<th>ChildNodes()</th>
				<td>子ノード一覧を取得します。</td>
			</tr>
			<tr>
				<th>Contains(SyntaxNode)</th>
				<td>引数として渡したノードが子孫に含まれるか判定します。</td>
			</tr>
			<tr>
				<th>DescendantNodes(Func&lt;SyntaxNode,Boolean&gt;, Boolean)</th>
				<td>子孫ノード一覧を取得します。</td>
			</tr>
			<tr>
				<th>GetLocation()</th>
				<td>当該ノードの所在情報を取得します。</td>
			</tr>
			<tr>
				<th>ToString()</th>
				<td>トリビアを除いたコードを文字列型として返します。</td>
			</tr>
			<tr>
				<th>IsKind(SyntaxNode, SyntaxKind)</th>
				<td>ノードの種類を判定します。</td>
			</tr>
		</tbody>
	</table>
</div>
<h2>子孫ノード一覧の取得</h2>
では、早速頂点に位置するノード配下のノード一覧を取得してみましょう♪
<code class="csharp">
	IEnumerable&lt;Document&gt; documents = project.Documents;
	foreach (Document document in documents)
	{
		SyntaxNode root = document.GetSyntaxRootAsync().Result;
		IEnumerable&lt;SyntaxNode&gt; nodes = root.DescendantNodes();
		foreach (SyntaxNode node in nodes)
		{
			Console.WriteLine(" ----- ----- ----- ----- ----- ");
			Console.WriteLine(node.ToString());
			Console.WriteLine(" ----- ----- ----- ----- ----- ");
		}
	}
</code>
<img src="/?S00/0251/DescendantNodes_withoutFiltering.gif" alt="DescendantNodes" />
ノード全てが取得されていることを確認できます。
<h2>ノードフィルタリング</h2>
先ほどはノード全てを取得しましたね♪<br />次はノードを一定の条件でフィルタリングしましょう♪<br /><br />ノードのフィルタリングには以下の2つの方法があります。
<ul>
	<li>LINQ</li>
	<li>判定関数</li>
</ul>
<h3>LINQ</h3>
DescendantNodesメソッドではノード一覧はIEnumerable型で取得しますので、これに対してLINQを使用することをフィルタリングを実現します。<br />では、ノードの中でsqlという文字を含むものをだけを取得しましょう♪
<code class="csharp">
	IEnumerable&lt;SyntaxNode&gt; nodes = root.DescendantNodes().Where(a =&gt; a.ToString().Contains("sql"));
	foreach (SyntaxNode node in nodes)
	{
		Console.WriteLine(" _____ _____ _____ _____ _____ ");
		Console.WriteLine(node.ToString());
		Console.WriteLine(" _____ _____ _____ _____ _____ ");
	}
</code>
<img src="/?S00/0251/DescendantNodes_withLinqFiltering.gif" alt="DescendantNodes LINQ" />
<h3>判定関数</h3>
「DescendantNodes」メソッドの第一引数に判定関数を渡すことで、当該条件を満たすノード配下のノードだけを取得できます。<br />全てを取得してLINQで絞り込む方法とは若干異なりますが、階層構造の下り方を指定する場合に使用できます。<br />判定関数は引数として「SyntaxNode」のデータ型を受け取り、戻り値には真偽値を返す関数である必要があります。<br />判定の条件を再利用する場合にはメソッドとして定義し、その場限りの場合にはラムダ式を使用することをオススメします。<br />ここでは簡単のため、ラムダ式を採用します。<br /><br />以下のコードを書き換えたものです。
<code class="charp">
	IEnumerable&lt;SyntaxNode&gt; nodes = root.DescendantNodes(a =&gt; a.ToString().Contains("sql"));
	foreach (SyntaxNode node in nodes)
	{
		Console.WriteLine(" _____ _____ _____ _____ _____ ");
		Console.WriteLine(node.ToString());
		Console.WriteLine(" _____ _____ _____ _____ _____ ");
	}
</code>
<h2>ノードの種類</h2>
ノードの種類は「SyntaxKind」列挙型で表現されます。<br />とにかく大量に存在します。
<p>一覧は<a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.codeanalysis.csharp.syntaxkind?view=roslyn-dotnet-4.2.0">MS公式ドキュメント</a>へ。</p>
SyntaxVisualyzerを使用して対象となるノードの種類を把握して、それを取得するのが一般的です。<br /><br />ここでは、sqlという文字を含む文を対象として取得しましょう♪<br />文という指定ができないので、限定列挙する必要があります。<br />今回は「ExpressionStatement」と「LocalDeclarationStatement」のみを対象としました。<br />まずは、限定列挙された種類に合致するかどうかの関数を作成します。
<code class="csharp">
	private static bool FilterStatement(SyntaxNode node)
	{
		SyntaxKind[] kinds = new SyntaxKind[]
		{
			SyntaxKind.LocalDeclarationStatement,
			SyntaxKind.ExpressionStatement
		};
		foreach (SyntaxKind kind in kinds)
		{
			if (node.IsKind(kind)) return true;
		}
		return false;
	}
</code>
次にLINQを使用して絞り込みます。
<code class="csharp">
	IEnumerable&lt;SyntaxNode&gt; nodes = root.DescendantNodes().Where(a =&gt; FilterStatement(a) &amp;&amp; a.ToString().Contains("sql"));
	foreach (SyntaxNode node in nodes)
	{
		Console.WriteLine(" _____ _____ _____ _____ _____ ");
		Console.WriteLine(node.ToString());
		Console.WriteLine(" _____ _____ _____ _____ _____ ");
	}
</code>
<img src="/?S00/0251/DescendantNodes_withDetailedFiltering.gif" alt="DescendantNodes" />
こんな感じで構文ノードの絞り込みを行います。
