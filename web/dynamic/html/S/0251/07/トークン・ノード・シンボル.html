<h2>トークン</h2>
字句解析によって生成される分割されたコードの最小単位です。<br />空白文字や特殊文字でコードを分割したもので、各トークンは独立に存在してそれぞれのトークンとしての意味を有するだけで、トークン間での階層構造はありません。
<img src="/static/img/S00/0251/token.png" alt="トークン" />
<h2>ノード</h2>
各トークンの文脈を判断して、各トークンに階層構造を設けたものです。<br />「文脈を判断する」とは、「{...}」「[...]」「(...)」内をひとつの集合としてとらえたり、「,」によって前後のトークンに対して配列の関係があることを認識することを言います。<br /><br />ノードは最低一つのトークンを有し、また再帰的にノードを有することもあります。<br />各ドキュメントは「CompilationUnit」を頂点のノードとするノードツリーと呼ばれる階層構造を形成します。
<img src="/static/img/S00/0251/node.png" alt="ノード" />
<img src="/static/img/S00/0251/syntaxTree.png" alt="構文ツリー" />
一般的には各ドキュメントから頂点となるノードを取り出して、それ以下のノードを探索していきます。<br />トークンが分割されたコードの最小単位とすると、ノードは意味を持ったノードと、そのノードの集合体として機能します。
<h2>シンボル</h2>
トークン・ノードはともにroslynの構文APIを使用して操作します。<br />これに対してシンボルはSemanticAPIを使用して操作するという違いがあります。<br />「Semantic」は和訳すると「意味的な」という意味になります。<br /><br />トークンはコードを最小単位に分割したもので、ノードによってトークンに階層構造を形成することは説明済みです。<br /><br />シンボルはプログラム実行時に必要となる「意味」を保持します。<br />例えば、ある変数がどこで定義されていて、どこで参照されているかなどです。<br />この機能によって、より柔軟に(プログラム実行を考えての)コードの解析が可能になります。
<h2>コンパイラAPI</h2>
roslynは「解析」「宣言」「バインド」「プログラム生成」の各段階において、オブジェクトモデルを公開しています。<br />実際に各段階でのデータにアクセスする際には、それらの上位に位置する「Language Service」にアクセスすることでこれを実現します。<br /><br />「Language Service」には以下の機能があります。
<ul>
	<li>Colorizer</li>
	<li>Outliting</li>
	<li>Find All References</li>
	<li>Object Browser</li>
	<li>Go To Definition</li>
	<li>...</li>
</ul>
<img src="/static/img/S00/0251/compilerPipeline.png" alt="コンパイラAPI" />
<p><a href="https://github.com/dotnet/roslyn/blob/main/docs/wiki/Roslyn-Overview.md">github</a>より。</p>
使用する機能によって対象のAPIを使い分けます。<br />例えば、コードの色づけをしたい場合は「構文API」を、オブジェクトブラウザを使用する場合には「シンボル」を、定義へ移動や全ての参照の検索を使用する場合は「セマンティックモデル」を使用します。
<img src="/static/img/S00/0251/stageOfCompilerAPI.png" alt="コンパイラAPI" />
<p><a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/roslyn-sdk/compiler-api-model">MS公式ドキュメント</a>より。</p>
<h2>構文ツリー</h2>
次に構文ツリーの構成要素について説明します。<br />主に以下の3つからなります。
<ul>
	<li>構文ノード</li>
	<li>構文トークン</li>
	<li>構文トリビア</li>
</ul>
<h3>構文ツリー</h3>
最初に構文ツリーについて説明します。<br />構文ツリーは構文ノードに階層構造を持たせたもので、以下の特徴を有します。
<ul>
	<li>全てのデータを保持</li>
	<li>解析元の正確なテキストを生成可能</li>
	<li>変更不可でスレッドセーフ</li>
</ul>
<p><a href="https://github.com/dotnet/roslyn/blob/main/docs/wiki/Roslyn-Overview.md">github</a>より。</p>
<h4>全てのデータを保持</h4>
当該構文ツリーを生成したドキュメントの全ての情報を保持します。<br />これには、空白類似文字やコメントアウトなどのトリビアも含まれます。
<h4>解析元の正確なテキストを生成可能</h4>
構文ツリーの構成要素は生成元となるデータ全てを保持します。<br />
<h4>変更不可でスレッドセーフ</h4>
<h3>構文ノード</h3>
構文ノードは構文ツリーの主要な構成要素であり、roslynを使用した構文解析の主要となる機能です。<br />構文ノードは再帰的に構文ノードを有し、最も下に位置する構文ノードはコード分解時の最小単位である構文トークンを有します。<br /><br />構文ノードは「Parent」プロパティで親ノードに、「ChildNodes」メソッドで子ノードに、「DescendantNodes」メソッドで子孫ノードに、「DescendantTokens」メソッドで子孫トークンに、「DescendantTrivia」メソッドで子孫トリビアにアクセス可能です。
<h3>構文トークン</h3>
字句解析によって生成されるコード分割の最小単位です。<br />コードの色付けをする際に使用されます。
<h3>構文トリビア</h3>
コードを整えるための空白類似文字やコメントアウトなどが該当します。
<h2>範囲</h2>
構文ノード・構文トークン・構文トリビアはソーステキスト内の各自の位置と構成文字数をプロパティとして保持しています。<br />具体的には以下のプロパティでアクセス可能です。
<ul>
	<li>Span</li>
	<li>FullSpan</li>
</ul>
両社の違いを説明します。
<table>
	<thead>
		<tr>
			<th width="50%">Span</th>
			<th width="50%">FullSpan</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>先頭または末尾のトリビアはいずれも含まれません。</td>
			<td>先頭または末尾のトリビアをそのまま出力します。</td>
		</tr>
	</tbody>
</table>
<h2>SyntaxVisualizer</h2>
構文ツリーを解析するためには「SyntaxVisualizer」を使用します。<br />これによって構文ツリーの階層構造を視覚的に把握できます。<br /><br />「表示 &gt; その他のウィンドウ &gt; Syntax Visualizer」から表示できます。
<img src="/static/img/S00/0251/SyntaxVisualizer.gif" alt="SyntaxVisualizer" />
