<h2>データ型</h2>
前回軽く説明したデータ型について説明します。<br />といっても、前回説明したデータ型を覚えればひとまず、OK!ですが、、、
<div class="scroll-600w">
	<table>
		<thead>
			<tr>
				<th>C#</th>
				<th>.NET</th>
				<th>説明</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>bool</td>
				<td>System.Boolean</td>
				<td>真偽値型です。<br />「True」「False」の2種類が該当します。</td>
			</tr>
			<tr>
				<td>byte</td>
				<td>System.Byte</td>
				<td>「0 ～ 255」までの整数を格納できます。</td>
			</tr>
			<tr>
				<td>sbyte</td>
				<td>System.SByte</td>
				<td>「-128 ～ 127」までの整数を格納できます。</td>
			</tr>
			<tr>
				<td>char</td>
				<td>System.Char</td>
				<td>Unicode UTF-16 文字を表すデータ型です。</td>
			</tr>
			<tr>
				<td>decimal</td>
				<td>System.Decimal</td>
				<td>誤差の出ない小数型で、主に財務目的で使用されます。</td>
			</tr>
			<tr>
				<td>double</td>
				<td>System.Double</td>
				<td>倍精度浮動小数点数型で、非常に高精度な小数型です。</td>
			</tr>
			<tr>
				<td>float</td>
				<td>System.Single</td>
				<td>単精度浮動小数点数型で、doubleほど高い精度が必要ない場合に使用します。</td>
			</tr>
			<tr>
				<td>int</td>
				<td>System.Int32</td>
				<td>一般的な整数型です。</td>
			</tr>
			<tr>
				<td>uint</td>
				<td>System.UInt32</td>
				<td>正の整数専用の整数型です。</td>
			</tr>
			<tr>
				<td>nint</td>
				<td>System.IntPtr</td>
				<td>環境によってデータサイズが変わる整数型です。<br />int型とほとんど同じです。</td>
			</tr>
			<tr>
				<td>nuint</td>
				<td>System.UIntPtr</td>
				<td>環境によってサイズが変わる正の整数専用の整数型です。<br />uint型とほとんど同じです。</td>
			</tr>
			<tr>
				<td>long</td>
				<td>System.Int64</td>
				<td>非常に大きなサイズの整数型です。</td>
			</tr>
			<tr>
				<td>ulong</td>
				<td>System.UInt64</td>
				<td>非常に大きなサイズの正の整数専用の整数型です。</td>
			</tr>
			<tr>
				<td>short</td>
				<td>System.Int16</td>
				<td>小さなサイズの整数型です。</td>
			</tr>
			<tr>
				<td>ushort</td>
				<td>System.UInt16</td>
				<td>小さなサイズの正の整数専用の整数型です。</td>
			</tr>
			<tr>
				<td>object</td>
				<td>System.Object</td>
				<td>万能のデータ型です。<br />便利ですのが、乱用はコードの可読性・パフォーマンス低下につながります。</td>
			</tr>
			<tr>
				<td>string</td>
				<td>System.String</td>
				<td>文字列型です。</td>
			</tr>
			<tr>
				<td>dynamic</td>
				<td>System.Object</td>
				<td>コードの実行時にデータ型が決まる特殊なデータ型です。<br />個人的には好きではありません。</td>
			</tr>
		</tbody>
	</table>
</div>
<p>公式ドキュメントは<a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/builtin-types/built-in-types">こちら</a>。</p>
「大きなサイズ」「小さなサイズ」と、曖昧な表現を使用しました。<br />より正確に、格納できる上限下限を知りたいは、<a>マイクロソフト公式ドキュメント</a>を参照してください。<br /><br />正直なところ、PCのスペックはかなり向上してきているため、メモリに関してはそこまで気にする必要もなく、そのためデータ型も使い分ける必要はありません。<br /><br />したがって、以下に列挙するデータ型だけ覚えればOK!です。
<table>
	<tbody>
		<tr>
			<th>int</th>
			<td>整数</td>
		</tr>
		<tr>
			<th>double</th>
			<td>小数</td>
		</tr>
		<tr>
			<th>string</th>
			<td>文字列</td>
		</tr>
		<tr>
			<th>boolean</th>
			<td>真偽値</td>
		</tr>
	</tbody>
</table>
<span class="pageSensitive">前回</span>説明した内容ですね♪
<div class="separator"></div>
文字列型は「"(ダブルクォーテーション)」で囲んで表記します。<br />「"りんご"」「"ラッコ"」という感じです。<br /><br />それ以外のデータ型はそのまま表記します。
<h2>演算</h2>
プログラミングと言えば!!!<br />みたいなものですね♪<br /><br />演算は大きく以下の3つに分類されます。
<ul>
	<li>算術演算</li>
	<li>関係演算</li>
	<li>論理演算</li>
</ul>
<h3>算術演算</h3>
算数のことです。<br />「&times;」の代わりに「*」、「&divide;」の代わりに「/」、割り算の余りを求めるには「\」を使うことを覚えてください。
<table>
	<tbody>
		<tr>
			<th>+</th>
			<td>足し算</td>
		</tr>
		<tr>
			<th>-</th>
			<td>引き算</td>
		</tr>
		<tr>
			<th>*</th>
			<td>掛け算</td>
		</tr>
		<tr>
			<th>/</th>
			<td>割り算</td>
		</tr>
		<tr>
			<th>\</th>
			<td>割り算の余り</td>
		</tr>
	</tbody>
</table>
<div class="separator"></div>
文字列型のデータに対して「+」を使用すると、文字列を結合することができます。
<h4>ショートハンド</h4>
コードを簡単に書くためのテクニックです。<br />最初に「x」変数に格納されている数字に「1」を加算処理を考えてください。
<code class="cs">
	x = x + 1;
</code>
おそらく、このコードを思い浮かべる人が多いと思います。<br />これに関して、もっと簡単に書くことが可能です。
<code class="cs">
	x += 1;
</code>
この記法は「+」以外の算術演算子にも使用可能です。<br /><br />さらに、対象の値が「1」の場合には、以下のように書くことも可能です。
<code class="cs">
	x++;
</code>
非常に簡単ですね♪<br />これを(後置)インクリメント記法と呼びます。<br /><br />マイナスの場合は「x--;」となり、(後置)デクリメント記法と呼ばれます。
<div class="separator"></div>
因みに、「++」を変数の後ろに書きましたが、前に書くパターンもあります。<br />前置インクリメント記法と呼ばれます。<br />後置インクリメント記法との相違点は、前置インクリメントは「1」を加算(減算)してから評価されることです。<br /><br />なんだかよくわかりませんね、、、
<img src="/static/img/S00/0251/postfixIncrement.png" alt="後置インクリメント記法" />
<img src="/static/img/S00/0251/prefixIncrement.png" alt="前置インクリメント記法" />
<h3>関係演算</h3>
2つのデータを比較します。<br />「比較演算」とも呼ばれます。<br /><br />評価の結果として真偽値を返します。
<table>
	<tbody>
		<tr>
			<th>&gt;</th>
			<td>右の値が左の値よりも大きければ「true」</td>
		</tr>
		<tr>
			<th>&lt;</th>
			<td>左の値が右の値よりも小さければ「true」</td>
		</tr>
		<tr>
			<th>&gt;=</th>
			<td>右の値が左の値以上ならば「true」<br />※イコールを含む</td>
		</tr>
		<tr>
			<th>&lt;=</th>
			<td>左の値が右の値以下ならば「true」<br />※イコールを含む</td>
		</tr>
		<tr>
			<th>==</th>
			<td>左と右の値が等しければ「true」</td>
		</tr>
		<tr>
			<th>!=</th>
			<td>左と右の値が異なれば「true」</td>
		</tr>
	</tbody>
</table>
<img src="/static/img/S00/0251/relationalOperator.png" alt="関係演算" />
<h3>論理演算</h3>
「かつ(AND)」と「または(OR)」と「ない(NOT)」による演算です。<br />演算対象は真偽値で評価結果として真偽値を返します。
<table>
	<tbody>
		<tr>
			<th>&amp;&amp;</th>
			<td>「かつ(AND)」による演算です。<br />両方とも「true」の場合にのみ「true」</td>
		</tr>
		<tr>
			<th>||</th>
			<td>「または(OR)」による演算です。<br />いずれかが「true」の場合に「true」</td>
		</tr>
		<tr>
			<th>!</th>
			<td>真偽値を逆転させます。<br />「!true」&rarr;「false」<br />「!false」&rarr;「true」</td>
		</tr>
	</tbody>
</table>
<img src="/static/img/S00/0251/logicalOperation.png" alt="論理演算" />
「&amp;&amp;」と「||」は短絡評価演算子と呼ばれ、全てを値を評価することなく、最終的な結果が定まった時点で評価を終了します。<br /><br />例えば、「A &amp;&amp; B」と式に関して、「A」が「false」である場合、その結果は絶対に「false」となるため、「B」に関しての評価は行われません。<br /><br />したがって、左の値が「true」の場合にのみ、右の値を評価したいという場合に使用することで、コードを簡単に書くことができます。
<div class="separator"></div>
「&amp;」「|」はぞれぞれ、「&amp;&amp;」「||」の短絡評価しないバージョンです。<br />実際のところ、ほとんど使用することはありません。
<h2>データ型の変換</h2>
ここでは、データ型を変換する方法を説明します。<br />「キャスト」と呼ぶこともあります。
<h3>継承関係にあるデータ型同士</h3>
コンパイラが自動で型変換を行ってくれる場合もありますが、保守性及び思わぬバグの防止のために明示的にデータ型を変換することをオススメします。<br /><br />因みに、データ型の演算ではコンパイラは自動で大きなサイズのデータ型に変換します。<br />例えば、「int」と「float」なら「float」、「short」と「long」なら「long」といった感じです。
<code class="cs">
	int x;
	double y;
	x = 5;
	y = 2;
	Console.WriteLine(x / y);

	/* &darr; コンソール &darr;
	2.5
	*/
</code>
上の処理では、「int」「double」のうち、演算結果はより大きい「double」に変換されます。<br /><br />しかしながら、この方法では不十分なこともあります。<br />例えば、整数型同士の割り算で結果が小数になる場合に、結果のデータ型は整数型であるため、小数点以下が切り捨てられます。<br />このような場合には、明示的に型変換をする必要があります。<br /><br />型変換は以下のように書きます。
<code class="cs">
	(データ型)値
</code>
では、整数型同士の割り算を行って、その結果を確認しましょう♪
<code class="cs">
	int x, y;
	x = 5;
	y = 2;
	Console.WriteLine(x / y);
	Console.WriteLine((double)x / y);

	/* &darr; コンソール &darr;
	2
	2.5
	*/
</code>
<img src="/static/img/S00/0251/explicitCast.gif" alt="明示的な型変換" />
<h3>文字列と数値型</h3>
<h4>文字列 &rarr; 数値</h4>
文字列型のデータを数値型に変換するには、以下のように書きます。
<code class="cs">
	数値型.TryParse(文字列, out 結果);
</code>
数値型の部分には、「int」「double」などを指定、文字列の部分にはデータ型変換対象の文字列を指定、結果の部分にはデータ型を変換した値を格納する変数を指定します。<br />正確には、データ型の変換に成功したか、失敗したかを判定する必要があるのですが、ここでは省略します。<br />また、「out」についても後ほど説明します。
<code class="cs">
	var num = Console.ReadLine();
	int answer;
	int.TryParse(num, out answer);
	Console.WriteLine(answer * 2);
</code>
<img src="/static/img/S00/0251/TryParseWithoutErrorHandling.gif" alt="TryParse" />
コンソール画面に入力された文字列が「num」変数に格納され、次にそれを型変換した際に格納するための「answer」を整数型で宣言しています。<br />実際に「num」変数に格納されている文字列を整数型に変換して、それを2倍した数字をコンソール画面に出力しています。
<div class="separator"></div>
「TryParse」ではない「Parse」メソッドも存在しますが、原則として「TryParse」を使用して下さい。<br />理由は、データ型の変換は必ずしも成功するとは限らず、失敗した際の対応をしないと例外が発生するからです。
<h4>数値 &rarr; 文字列</h4>
数値型のデータを文字列型に変換するには「ToString」メソッドを使用します。
<code class="cs">
	int num = 12345;
	Console.WriteLine(num.ToString() + " !!!");

	/* &darr; コンソール &darr;
	12345 !!!
	*/
</code>
また、「D」「N」に数字を続けた引数を渡すことで、最小桁数・小数点以下桁数を指定可能です。
<p>引数については後ほど説明しますが、かっこの中に書くデータのことだと思ってください。</p>
<img src="/static/img/S00/0251/ToString.png" alt="ToString" />
指定した桁数が足りない場合には、桁数指定は無視されます。
<h2>NULL</h2>
「NULL」とは、値がなにもないことを意味します。<br />「0」でも「""(空文字)」でもなく、本当に空っぽです。<br /><br />古い言語ではほとんど「NULL」をサポートしてると思いますが、これが非常に厄介です。<br /><br />「NULL」の概念はアントニー・ホーアというプログラマが考案したものですが、彼はこれを「10億ドルの失敗」と呼んでいます。
<div class="quote">
	<div><a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">NULL参照(10億ドルの誤り)</a></div>
	<div>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</div>
</div>
<h3>NULL許容型・非許容型</h3>
新しい言語では、そもそも「NULL」を使用しない、または「NULL」に関して厳格なルールを定めていることが多いです。<br /><br />C#は「NULL」に関して少し特殊で、「NULL」を許容するか否かをデータ型に付して管理します。<br /><br />デフォルトでは、「NULL」を許容しませんが、変数宣言時に「データ型? 変数名」とすることで、「NULL」を許容するデータ型として設定可能です。<br /><br />では、実際にコードを書いてみましょう♪
<code class="cs">
	/* コンパイルエラー */

	int num = null;

	/* &darr; コンソール &darr;
	Null 非許容の値型であるため、Null を 'int' に変換できません
	*/
</code>
<code class="cs">
	int? num = null;
</code>
<h3>NULL判定</h3>
値が「NULL」かどうかを判定するには、以下の2通りの方法があります。
<ul>
	<li>==</li>
	<li>??</li>
</ul>
<h4>==によるNULL判定</h4>
そのまま「== NULL」とすることで、その値がNULLかどうかを判定します。<br />「!=」で「非NULL」を判定できます。
<img src="/static/img/S00/0251/comparisionToNull.png" alt="NULL制御" />
<h4>??による判定</h4>
NULL合体演算子と呼びます。<br />「A ?? B」と書くことで、Aの値が「NULL」の場合にBの値を使用します。<br />これは複数連結させることもできます。
<img src="/static/img/S00/0251/nullCoalescingOperator.png" alt="NULL合体演算子" />